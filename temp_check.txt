// 迚ｩ莉ｶ繝ｪ繧ｹ繝医・CRUD繧ｵ繝ｼ繝薙せ
import { createClient } from '@supabase/supabase-js';
import { Pool } from 'pg';
import { PropertyDistributionAreaCalculator } from './PropertyDistributionAreaCalculator';
import { CityNameExtractor } from './CityNameExtractor';

export class PropertyListingService {
  private supabase;
  private pool: Pool;
  private distributionCalculator: PropertyDistributionAreaCalculator;
  private cityExtractor: CityNameExtractor;

  constructor() {
    this.supabase = createClient(
      process.env.SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_KEY!
    );
    // 逶ｴ謗･PostgreSQL謗･邯夲ｼ・ostgREST繧ｭ繝｣繝・す繝･蝠城｡後ｒ蝗樣∩・・
    this.pool = new Pool({
      connectionString: process.env.DATABASE_URL,
      ssl: { rejectUnauthorized: false }
    });
    this.distributionCalculator = new PropertyDistributionAreaCalculator();
    this.cityExtractor = new CityNameExtractor();
  }

  async getAll(options: {
    limit?: number;
    offset?: number;
    orderBy?: string;
    orderDirection?: 'asc' | 'desc';
    search?: string;
    status?: string;
    salesAssignee?: string;
    propertyType?: string;
  } = {}) {
    const {
      limit = 50,
      offset = 0,
      orderBy = 'created_at',
      orderDirection = 'desc',
      search,
      status,
      salesAssignee,
      propertyType,
    } = options;

    let query = this.supabase
      .from('property_listings')
      .select('*', { count: 'exact' });

    // 繝輔ぅ繝ｫ繧ｿ繝ｪ繝ｳ繧ｰ
    if (search) {
      query = query.or(`property_number.ilike.%${search}%,address.ilike.%${search}%,seller_name.ilike.%${search}%`);
    }
    if (status) {
      query = query.eq('status', status);
    }
    if (salesAssignee) {
      query = query.eq('sales_assignee', salesAssignee);
    }
    if (propertyType) {
      query = query.eq('property_type', propertyType);
    }

    // 繧ｽ繝ｼ繝・
    query = query.order(orderBy, { ascending: orderDirection === 'asc' });

    // 繝壹・繧ｸ繝阪・繧ｷ繝ｧ繝ｳ
    query = query.range(offset, offset + limit - 1);

    const { data, error, count } = await query;

    if (error) {
      throw new Error(`Failed to fetch property listings: ${error.message}`);
    }

    return { data: data || [], total: count || 0 };
  }

  async getByPropertyNumber(propertyNumber: string) {
    const { data, error } = await this.supabase
      .from('property_listings')
      .select('*')
      .eq('property_number', propertyNumber)
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return null;
      }
      throw new Error(`Failed to fetch property listing: ${error.message}`);
    }

    return data;
  }

  async update(propertyNumber: string, updates: Record<string, any>) {
    // 菴乗園縺梧峩譁ｰ縺輔ｌ縺溷ｴ蜷医・・菫｡繧ｨ繝ｪ繧｢繧貞・險育ｮ・
    if (updates.address) {
      try {
        // 迴ｾ蝨ｨ縺ｮ迚ｩ莉ｶ諠・ｱ繧貞叙蠕・
        const currentProperty = await this.getByPropertyNumber(propertyNumber);
        
        if (currentProperty) {
          // 蟶ょ錐繧呈歓蜃ｺ
          const city = this.cityExtractor.extractCityFromAddress(updates.address);
          
          // 驟堺ｿ｡繧ｨ繝ｪ繧｢繧定ｨ育ｮ・
          const result = await this.distributionCalculator.calculateDistributionAreas(
            currentProperty.google_map_url || updates.google_map_url,
            city,
            updates.address
          );
          
          // 驟堺ｿ｡繧ｨ繝ｪ繧｢繧呈峩譁ｰ繝・・繧ｿ縺ｫ霑ｽ蜉
          updates.distribution_areas = result.formatted;
          
          console.log(`[PropertyListingService] Recalculated distribution areas for ${propertyNumber}: ${result.formatted}`);
        }
      } catch (error) {
        console.error(`[PropertyListingService] Failed to recalculate distribution areas:`, error);
        // 繧ｨ繝ｩ繝ｼ縺檎匱逕溘＠縺ｦ繧よ峩譁ｰ縺ｯ邯夊｡・
      }
    }

    const { data, error } = await this.supabase
      .from('property_listings')
      .update({ ...updates, updated_at: new Date().toISOString() })
      .eq('property_number', propertyNumber)
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to update property listing: ${error.message}`);
    }

    return data;
  }

  async getStats() {
    // 諡・ｽ楢・挨莉ｶ謨ｰ
    const { data: byAssignee } = await this.supabase
      .from('property_listings')
      .select('sales_assignee')
      .not('sales_assignee', 'is', null);

    // 遞ｮ蛻･蛻･莉ｶ謨ｰ
    const { data: byType } = await this.supabase
      .from('property_listings')
      .select('property_type')
      .not('property_type', 'is', null);

    // 迥ｶ豕∝挨莉ｶ謨ｰ
    const { data: byStatus } = await this.supabase
      .from('property_listings')
      .select('status')
      .not('status', 'is', null);

    const assigneeCounts: Record<string, number> = {};
    byAssignee?.forEach(row => {
      const key = row.sales_assignee || '譛ｪ險ｭ螳・;
      assigneeCounts[key] = (assigneeCounts[key] || 0) + 1;
    });

    const typeCounts: Record<string, number> = {};
    byType?.forEach(row => {
      const key = row.property_type || '譛ｪ險ｭ螳・;
      typeCounts[key] = (typeCounts[key] || 0) + 1;
    });

    const statusCounts: Record<string, number> = {};
    byStatus?.forEach(row => {
      const key = row.status || '譛ｪ險ｭ螳・;
      statusCounts[key] = (statusCounts[key] || 0) + 1;
    });

    return {
      byAssignee: assigneeCounts,
      byType: typeCounts,
      byStatus: statusCounts,
    };
  }


  // 蜈ｬ髢狗黄莉ｶ荳隕ｧ蜿門ｾ暦ｼ医し繧､繝郁｡ｨ遉ｺ縺ｮ縺ｿ・・ 逶ｴ謗･PostgreSQL謗･邯壹ｒ菴ｿ逕ｨ
  async getPublicProperties(options: {
    limit?: number;
    offset?: number;
    propertyType?: string;
    priceRange?: { min?: number; max?: number };
    areas?: string[];
  } = {}) {
    const {
      limit = 20,
      offset = 0,
      propertyType,
      priceRange,
      areas,
    } = options;

    try {
      // 逶ｴ謗･PostgreSQL謗･邯壹ｒ菴ｿ逕ｨ・・ostgREST繧ｭ繝｣繝・す繝･蝠城｡後ｒ蝗樣∩・・
      const params: any[] = [];
      let paramIndex = 1;
      
      let whereClause = `WHERE site_display = '繧ｵ繧､繝郁｡ｨ遉ｺ'`;
      
      if (propertyType) {
        whereClause += ` AND property_type = $${paramIndex}`;
        params.push(propertyType);
        paramIndex++;
      }
      
      if (priceRange?.min !== undefined) {
        whereClause += ` AND price >= $${paramIndex}`;
        params.push(priceRange.min);
        paramIndex++;
      }
      
      if (priceRange?.max !== undefined) {
        whereClause += ` AND price <= $${paramIndex}`;
        params.push(priceRange.max);
        paramIndex++;
      }
      
      if (areas && areas.length > 0) {
        const areaConditions = areas.map((area, idx) => {
          params.push(`%${area}%`);
          return `distribution_areas LIKE $${paramIndex + idx}`;
        }).join(' OR ');
        whereClause += ` AND (${areaConditions})`;
        paramIndex += areas.length;
      }
      
      // 繧ｫ繧ｦ繝ｳ繝医け繧ｨ繝ｪ・医ヱ繝ｩ繝｡繝ｼ繧ｿ縺ｮ繧ｳ繝斐・繧剃ｽｿ逕ｨ・・
      const countParams = [...params];
      const countQuery = `SELECT COUNT(*) as total FROM property_listings ${whereClause}`;
      const countResult = await this.pool.query(countQuery, countParams);
      const total = parseInt(countResult.rows[0]?.total || '0', 10);
      
      // 繝・・繧ｿ繧ｯ繧ｨ繝ｪ - LIMIT/OFFSET縺ｮ繝代Λ繝｡繝ｼ繧ｿ繧､繝ｳ繝・ャ繧ｯ繧ｹ繧呈ｭ｣縺励￥險ｭ螳・
      const limitParamIndex = paramIndex;
      const offsetParamIndex = paramIndex + 1;
      const dataQuery = `
        SELECT 
          id,
          property_number,
          property_type,
          address,
          price,
          land_area,
          building_area,
          construction_year_month,
          image_url,
          distribution_areas,
          created_at
        FROM property_listings
        ${whereClause}
        ORDER BY created_at DESC
        LIMIT $${limitParamIndex} OFFSET $${offsetParamIndex}
      `;
      params.push(limit, offset);
      
      const dataResult = await this.pool.query(dataQuery, params);
      
      return { 
        properties: dataResult.rows || [], 
        total,
        limit,
        offset 
      };
    } catch (error: any) {
      console.error('Error in getPublicProperties (direct PG):', error);
      throw new Error(`Failed to fetch public properties: ${error.message}`);
    }
  }

  // 蜈ｬ髢狗黄莉ｶ隧ｳ邏ｰ蜿門ｾ暦ｼ医し繧､繝郁｡ｨ遉ｺ縺ｮ縺ｿ・・ 逶ｴ謗･PostgreSQL謗･邯壹ｒ菴ｿ逕ｨ
  async getPublicPropertyById(id: string) {
    try {
      const query = `
        SELECT 
          id,
          property_number,
          property_type,
          address,
          price,
          land_area,
          building_area,
          construction_year_month,
          floor_plan,
          image_url,
          google_map_url,
          distribution_areas,
          remarks,
          created_at,
          updated_at
        FROM property_listings
        WHERE id = $1 AND site_display = '繧ｵ繧､繝郁｡ｨ遉ｺ'
        LIMIT 1
      `;
      
      const result = await this.pool.query(query, [id]);
      
      if (result.rows.length === 0) {
        return null;
      }
      
      return result.rows[0];
    } catch (error: any) {
      console.error('Error in getPublicPropertyById (direct PG):', error);
      throw new Error(`Failed to fetch public property: ${error.message}`);
    }
  }

  // 蝠上＞蜷医ｏ縺帑ｽ懈・
  async createInquiry(inquiry: {
    name: string;
    email: string;
    phone?: string;
    message: string;
    propertyId?: string;
    ipAddress: string;
  }) {
    const { data, error } = await this.supabase
      .from('property_inquiries')
      .insert({
        name: inquiry.name,
        email: inquiry.email,
        phone: inquiry.phone,
        message: inquiry.message,
        property_id: inquiry.propertyId,
        ip_address: inquiry.ipAddress,
        created_at: new Date().toISOString(),
      })
      .select()
      .single();

    if (error) {
      throw new Error(`Failed to create inquiry: ${error.message}`);
    }

    return data;
  }

  // 蜈ｬ髢狗黄莉ｶ縺ｮID荳隕ｧ蜿門ｾ暦ｼ医し繧､繝医・繝・・逕ｨ・・ 逶ｴ謗･PostgreSQL謗･邯壹ｒ菴ｿ逕ｨ
  async getAllPublicPropertyIds(): Promise<string[]> {
    try {
      const query = `
        SELECT id
        FROM property_listings
        WHERE site_display = '繧ｵ繧､繝郁｡ｨ遉ｺ'
        ORDER BY created_at DESC
      `;
      
      const result = await this.pool.query(query);
      
      return (result.rows || []).map(row => row.id);
    } catch (error: any) {
      console.error('Error in getAllPublicPropertyIds (direct PG):', error);
      throw new Error(`Failed to fetch public property IDs: ${error.message}`);
    }
  }
}

